# Goroutine 调度器GPM模型的设计思想

## 什么是 GPM
- G goroutine 协程
- P processor 处理器
- M machine -> 内核线程
![GPM](./GPM.png)

- 全局队列
    - 存放等待运行的G
- P的本地队列
    - 存放等待运行的G
    - 有限 (256个G)
    - 创建的G优先放入本地队列，满了后放入全局队列。
- P列表
    - 程序启动时创建
    - 最多有 `GOMAXPROCS`个（可以配置）
        - 环境变量 $GOMAXPROCS
        - 程序中 `runtime.GOMAXPROCS()`
- M列表
    - 当前操作系统分配到Go的内核线程数
        - Go 限定最大量是 10000
        - `runtime/debug.SetMaxThreads`
        - 一般会动态调节
    - 一旦一个M阻塞，会创建一个新的
    - 一旦一个M空闲，将会被回收或睡眠


## GPM 的设计策略
- 复用线程
    - `work stealing` 偷取机制
        - 当某一个 P 处于空闲状态，它会从其他 P 中偷取队列中的 G 来执行

    - `hand off` 离手机制
        - 当 M1 下执行的 G1 出现了阻塞，系统会创建或者唤醒一个 M2, 并将 M1 脱离它的的本地队列[G2, G3....]， M2 接管该队列。 M1 会进入睡眠状态，甚至销毁， G1 加入其他队列。
- 利用并行
    - 可以使用多个CPU 同时运行
    - 但利用的CPU数有限制，`GOMAXPROCS` 限定的 P 的个数 = CPU核数 / 2
- 抢占
    - 在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。
- 全局 G 队列
    - P 执行 G 的优先级： 本地队列 > 全局队列 > 偷取其他 P 的本地队列


## go func() 
![gofunc](./gofunc.jpeg)
1. 我们通过 go func()来创建一个goroutine；

2. 有两种存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；

3. G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；

4. 一个M调度G执行的过程是一个循环机制；

5. 当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；

6. 当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。