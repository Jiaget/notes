# SSL/TLS概述
`SSL/TLS`是`HTTP`的加密协议。本篇会围绕以下内容讲解

|                                                |                           |
| ---------------------------------------------- | ------------------------- |
| Handshake                                      | (握手)                    |
| Symmetric cryptography                         | (对称密码学)              |
| Asymmetric cryptography                        | (非对称密码学)            |
| Elliptic-curve cryptography                    | (椭圆曲线密码学)          |
| Digital certificates                           | (数字证书)                |
| Certificate authority                          | (证书颁发)                |
| Digital signature                              | (数字签名)                |
| Diffie Hellman                                 | (迪菲-赫尔曼密钥交换算法) |
| Message authentication code                    | (消息验证码)              |
| Bit-flipping attack                            | (字节翻转攻击)            |
| Quantum-computing attack                       | (量子计算攻击)            |
| HKDF (HMAC-based KDF(key derivation function)) | (于HMAC的密钥推导函数)    |
| 0-RTT                                          |                           |
| AEAD                                           |                           |

## SSL / TLS
- SSL (secure Socket Layer) 安全套接层是TLS的前身

- TLS 全称 (transport layer security) 安全网络传输协议

## TLS 的作用
- `website` 的 `HTTPS` 
  -  `HTTP + TLS`
- `Email` 的 `SMTPS`
  - `SMPT + TLS`
- 文件传输 `file transfer` 的 `FTPS`
  - `FTP + TLS`

为这三类应用层协议提供了安全加密服务。

TLS 提供了？
- 认证 `Authentication`
  - 使用非对称密码学来验证访问者身份。
- 保密 `Confidentiality`
  - 用对称密码学保护在未经认证的访问过程中交换的数据。
- 可靠 `integrity `
  - 使用消息验证码机制保护数据

## TLS 的运作机制
- 握手协议 （认证）
  - 客户端和服务端统一`TLS`协议版本
  - 选择一个密钥算法：一个密钥套件
  - 使用非对称密码学进行认证
  - 使用对称密码学需要建一个`secret key`。
- 记录协议 (保密，可靠)
  - 使用 `secret key` 加密消息并发送
  - 使用 `secret key` 解密收到的消息
  - 验证消息没有被修改

## 为什么既有对称密钥算法，又有非对称密钥算法
- 对称密钥算法不能用来认证。
  - 客户端和服务端都有一个secret key，仅凭secret key难以判断双方的身份。
  - 双方如何生成secret key？如果将secret key暴露，认证本身也不再安全。
- 非对称密钥算法的效率低下，不适合批量加密
  - 和对称密钥相比，慢了100-1000倍
  
## 对称密钥算法
我们都知道，对称密钥算法要求双方事先共享secret key，消息发送者使用secret key加密，消息接收者使用secret key解密，这样即使消息在网络上被黑客截获，他也不知道消息的内容。
- bit-flipping 字节翻转攻击
  - 黑客可以截获对称密钥算法加密的消息，并将消息（二进制）中的1，0互换，篡改消息内容，再发送出去。如果发生在银行交易业务中，这将很危险。
  - 应对方法：认证加密。（如下图）
  
    ### 加密流程
  ![ACED](./AEAD.png)
  - 1.加密
    - 使用一个加密算法将消息加密，该加密算法还会采取secret key和一个随机数（或者一个初始化向量（IV））作为输入。
  - 2.身份认证
    - MAC （GMAC/POLY1305）将加密的消息再进行一次加密，同样也会带上上一步的secret key和随机数或者IV.
      - MAC算法类似加密哈希函数，输出的是MAC或者消息身份验证码
      - MAC会标记在加密消息上，然后一同发送给接收者。MAC因此也被叫做身份验证标签。
  - 另外
    - TLS 1.3中， 会有一些相关数据需要验证，比如地址，端口，版本协议，序列号等。这些数据不会被加密，而且通信双方都知道。
    ### 解密流程
    ![decryption](./AEAD2.png)
    其实就是加密的反过程。

    只是接收者拿到加密消息会先获取附加在上面的MAC,再通过MAC解密获得另一个的MAC。如果两个MAC不同，说明数据经过修改。
# secret key 怎么交换的？ - 密钥交换算法
对称算法中扮演至关重要的secret key是怎么做到交换的？我们不可以将它泄露到公共网络，不然加密算法将毫无意义。
- 使用 非对称算法 或者 公钥
  - 迪菲-赫尔曼(Diffie-Hellman Ephemerol) DHE
  - 椭圆曲线迪菲-赫尔曼 (Elliptic Curve Diffie-Hellman) ECDHE
  
迪菲-赫尔曼工作流程
![迪菲赫尔曼](./Diffie-hellman.png)
- 1. 首先 `Alice` 和 `Bob` 双方会共同认定两个数`g`（base） 和 `p` (mod)
- 2. 双方都会选一个私有数，比如 `Alice` 的 `a` 和 `Bob` 的 `b`
- 3. 他们都会通过如下公式运算得到的数发送给对方
  ```
  A = (g^a) mod p
  B = (g^b) mod p
  ```
- 4. 双方收到后，再进行相同的运算, 最后得到的数是相同的
  ```
  S = (B^a) mod p
  S = (A^b) mod p
  ```
我们可以通过简单的计算来验证上面说的现象
```
(B^a) mod p = (g^b)^a mod p = ( g^(b*a) ) mod p
(A^b) mod p = (g^a)^b mod p = ( g^(a*b) ) mod p
```

## 衍生功能 KDF (key derivation function) 密钥传导功能
该功能将输出共享密钥的所需长度。

![kdf](kdf.png)
我们需要：
- IKM（Input Key Material） 即刚才生成的数字`S = A^b mod p`
- Key的长度 比如 `128 bit`
- 加密哈希函数 如 `HMAC-SHA256`
- （可选）上下文，或者特定信息
- （可选） salt...

## 陷阱门
回到迪菲-赫尔曼的key交换。

在迪菲-赫尔曼算法中，下面信息是公有信息 
`p, g, A, B`

也就是说，黑客也能获取这些数字，所以，这些数字泄露后，能否还能保证消息交换机制的安全性。也就是说，黑客如果知道了这些公有数，能否通过某个公式算出 `a,b` 甚至是 `S`。

如果我们选择合适的数，就能成为一个陷阱门。黑客想要破解将要耗费大量的时间。

![trapdoor](trapdoor.png)

比如：
- `p` 作为一个 `mod` 数，可以选择一个素数 `2048-bit`
- 选择一个原始根模 `g`
- 选择随机整数 `a` `b` `256-bit`

陷阱门的意思是指：
- 用 `a, p, g` , 我们可以很容易算出 `A`  `A = g ^ a mod p`
- 但是 只有`A, p, g`， 我们就很难算出 `a`

至少这个问题在当前是无法计算出来的。

## 静态还是临时？
![static](static.png)
如果我们使用静态的 `key`: `a`, `b`。

当双方进行频繁得建立会话，黑客可以通过不断记录他们交换的 `S`, 并尝试去破解它。

虽然这可能需要很长时间，但是假如密钥没有更换，黑客还是有可能破解密钥。这同样是危险的问题。

所以我们得使用临时密钥。即每建立一个会话我们都生成新的密钥，即使黑客计算出其中一个会话的密钥，也将会失效。
![ephemeral](ephemeral.png)

# 椭圆曲线密码学（ELLIPTC-CURVE CRYPTOGRAPHY）
即ECC。是一种非对称加密算法。流程与上类似，但是使用的陷阱门函数不同。

该陷阱门函数基于椭圆曲线的代数结构。

它的价值在于：使用更小的key来提供相等的安全等级。

但是该算法容易受到量子计算攻击 
[肖尔算法](https://en.wikipedia.org/wiki/Shor%27s_algorithm)

虽然这些都是在量子计算机出现之后才需要担心的问题，但是也有另一个基于椭圆曲线密码学的交换算法 [超星体异质差异-赫尔曼](https://en.wikipedia.org/wiki/Supersingular_isogeny_key_exchange)

# 不对称密码学

![asymmetric](./asymmetric.png)
- Alice 使用 Bob 的公钥加密消息
- Bob 使用 自己的私钥进行解密

私钥和公钥虽然不同，但是可以使用一些陷阱门函数将两种密钥关联起来。就像`迪菲-赫尔曼`算法一样。

关键点：只有使用一对公私钥才能加密/解密消息。

也就是说，暴露在公共区域的黑客，即使拿到了公钥和消息，也不能解密消息。

## 公钥共享
公钥共享很简单，只需要Bob通过互联网对Alice发送公钥即可

### 中间人交换密钥
然而，黑客是可以干扰公钥的，他可以在Bob发送公钥的时候，中途截获，并替换自己的公钥。这样，如果Alice使用这个公钥加密消息，她发送的消息就可以被黑客拿去解密。

因此，为了防止有人篡改私钥，我们需要加一个身份认证-数字证书

## 数字证书
数字证书是一个有公信力的第三方授权的。该第三方具备能防止伪造数字证书的技术。
### 证书签名
![sign](./sign.png)
- Bob有一对公私钥
- Bob创建了证书签名请求(certificate signing request, CSR)。该请求包括 公钥和一些身份信息（姓名，组织，email等）
- Bob对该CSR使用私钥进行签名，并发送给认证机构（CA）
- CA会根据证书验证Bob身份。（甚至联系他，要求提供更多证据）
- CA使用Bob的公钥来验证签名，也是为了确认Bob有和证书匹配的公钥
- 如果认证通过，CA会用自己的私钥给证书签字，并发送给Bob
  
## 证书共享
Bob和Alice每次发送消息时，都会通过证书来认证身份。

黑客无法在篡改公钥，因为他无法制作假证书。

但是，这一切都需要CA有公信度，否则CA如果将私钥给黑客，那这一系列机制就毫无意义。

## 证书管理局 信任链
![chain](./chain.png)

最高级别的时根证书机构，他会签署自己的证书以及其下属（中间证书机构）证书。

中间证书机构同时也会签署其他的中键机构，也可以签署最终证书。

每个证书都能返回至根证书。

操作系统和浏览器储存了根证书列表，这样就可以验证基本所有的证书了。

## 数字签名
![signature](./signature.png)
- 签名
  - 签名者先对证书进行哈希
  - 使用私钥对哈希值加密，获得数字签名
  - 再将这个数字签名附加到原始的证书上 

- 验证
  - 获取签名
  - 使用签名人的公钥解密，获取哈希值
  - 使用相同的哈希算法对证书（不加签名的）进行哈希处理，获取另一个哈希值
  - 比较两个哈希值，相同，则签名有效

# TLS 1.3 握手协议
我们将使用上述所有知识来整理TLS 1.3的工作流程
## 完全握手
![full](./fullhand.png)
在客户端给服务器发送`Hello`消息开始。该消息包含很多东西，这里只列出重要的信息
-  客户端支持的协议版本列表
-  支持AEAD对称密码套件列表
-  支持的密钥交换算法列表,比如栗子中的 `迪菲-赫尔曼临时算法`和`椭圆曲线迪菲-赫尔曼临时算法`
-  针对两个算法各提供一个公钥
-  签名算法列表

受到客户端的消息后，服务端返回消息
- 选定的TLS 1.3协议
- 选定密码套件 `AES-256-GCM`
- 选定密钥交换方法 `迪菲-赫尔曼·埃菲默拉尔`
- 选定公钥
- 证书请求[可选项]
- HTTPS网站上，服务端还会给客户端发送证书
- 证书验证。
- 从客户端发送消息到证书签名之前的信息被称为上下文。这里会对上下文和证书进行哈希，并使用客户端支持的一个签名算法和服务器的私钥签署哈希值
- 类似的，将上下文，证书，验证哈希得到哈希值，使用密码套件中的MAC算法生成整个握手的MAC

服务器证书，证书验证，服务器完成都是身份验证消息，用于验证服务。

客户端受到服务端的消息后，他会验证证书，检查签名和MAC确保消息没有被篡改。

确认后，客户端会发送完成消息。

## 带PSK恢复的简单握手
完全握手的过程过于复杂，为了提高性能，有时候会使用预共享密钥的简单握手

在完全握手之后，服务器和客户端都能知道对方的存在，因此也不需要在进行上面复杂的流程。
![resumption](./resumption.png)
服务器会给客户端发一个票据，票据包括它的 `id` 和 `有效期`

在下一次的握手中：
客户端：
- 发送上次握手获得的PSK身份列表
- PKS 密钥交换模式：`PSK` 或 `PSK + 迪菲-赫尔曼`
- 如果交换模式选择`迪菲-赫尔曼`，还需要公钥

服务器：
- 返回一个`PSK id`
- 迪菲-赫尔曼公钥
- 服务器完成

最后客户端返回一个完成消息。

在这个简单握手中，客户端-服务器之间省略了证书身份验证。

在握手结束后，发送应用数据到服务器。

## 0-RTT 握手
零往返握手协议中，客户端会将应用数据和`hello`消息一起发送，该数据会使用票证列表中第一个 `PSK` 进行加密。

同时还增加了一个字段 `early data indication` ， 告诉服务器有一个较早的程序数据要发送。

当服务器接受这个请求，它会和 `简单握手` 一样，发送一个服务器的 `hello` 消息。

客户端最后发送一个带 `end of early data ` 的 `client finish` 来完成这次握手。

`0-RTT` 将延迟缩短了一次往返时间，缺点在于存在 retry 攻击的危险。

黑客只需要多次复制并发送相同的 `0-RTT` 请求到服务器。因此，我们还必须对重复发送的请求采取一些灵活的措施。

# TLS 1.3 vs TLS 1.2
![vs](./1.3vs1.2.png)

